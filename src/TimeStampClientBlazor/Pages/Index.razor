@page "/"
@using System.IO
@using System.Text
@inject IJSRuntime JSRuntime

<h1>TimeStampClientBlazor</h1>

<h3>Upload Files</h3>

<p>
    <label>
        Upload file up to @maxFileSize bytes:
        <InputFile OnChange="@LoadFiles" />
        <button @onclick="@GenerateFile" disabled="@isDisabled">Generate</button>
    </label>
</p>

<p>@exceptionMessage</p>

@if (isLoading)
{
    <p>Loading...</p>
}

<ul>
    @foreach (var (file, content) in loadedFiles)
    {
        <li>
            <ul>
                <li>Name: @file.Name</li>
                <li>Size (bytes): @file.Size</li>
                <li>Content type: @file.ContentType</li>
            </ul>
        </li>
    }
</ul>

@code {
    private Dictionary<IBrowserFile, string> loadedFiles = new Dictionary<IBrowserFile, string>();
    private long maxFileSize = 1024 * 1000;
    private bool isLoading;
    string exceptionMessage;
    Stream stream = null;
    StreamReader reader = null;
    string fileName = null;
    bool isDisabled = true;

    async Task LoadFiles(InputFileChangeEventArgs e)
    {
        isLoading = true;
        ClearInfo();
        exceptionMessage = string.Empty;

        try
        {
            this.reader = new StreamReader(e.File.OpenReadStream(maxFileSize));
            this.stream = e.File.OpenReadStream(maxFileSize);
            this.fileName = e.File.Name;
            isDisabled = false;

            loadedFiles.Add(e.File, await this.reader.ReadToEndAsync());
        }
        catch (Exception ex)
        {
            exceptionMessage = ex.Message;
        }

        isLoading = false;
    }

    async Task GenerateFile()
    {
        if (this.stream != null && !string.IsNullOrEmpty(this.fileName))
        {
            MemoryStream ms = new MemoryStream();
            await this.stream.CopyToAsync(ms);
            ms.Position = 0;
            var timeStampToken = await Disig.TimeStampClient.TimeStampClient.RequestTimeStampTokenUpdatedAsync("https://localhost:5001/tsa", ms);
            stream.Dispose();
            ms.Position = 0;

            await SaveToAsicSimple(this.fileName, timeStampToken, ms);
        }

        ClearInfo();
        isDisabled = true;
    }

    async Task DownloadAsics(string fileName, MemoryStream fileInput)
    {
        byte[] file = fileInput.ToArray();
        await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", Path.GetFileNameWithoutExtension(fileName) + ".asics", "application/vnd.etsi.asic-s+zip", file);
    }

    async Task SaveToAsicSimple(string inputName, Disig.TimeStampClient.TimeStampToken timeStampToken, Stream inputStream)
    {
        using (Ionic.Zip.ZipFile zipFile = new Ionic.Zip.ZipFile(UTF8Encoding.UTF8))
        {
            zipFile.ParallelDeflateThreshold = -1;
            zipFile.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Never;
            zipFile.EmitTimesInUnixFormatWhenSaving = false;
            zipFile.EmitTimesInWindowsFormatWhenSaving = false;
            zipFile.Comment = @"mimetype=application/vnd.etsi.asic-s+zip";

            using (MemoryStream ms = new MemoryStream())
            {
                zipFile.AddEntry(@"mimetype", System.Text.UTF8Encoding.UTF8.GetBytes(@"application/vnd.etsi.asic-s+zip"));
                zipFile.AddEntry(inputName, inputStream);
                zipFile.AddEntry(@"META-INF/timestamp.tst", timeStampToken.ToByteArray());
                zipFile.Save(ms);

                await DownloadAsics(inputName, ms);
            }
        }
    }

    public void ClearInfo()
    {
        this.fileName = null;
        this.stream = null;
        this.reader = null;
        loadedFiles.Clear();
    }
}
